CREATE TABLE IF NOT EXISTS klines_1m (
    time TIMESTAMPTZ NOT NULL,
    symbol TEXT NOT NULL,
    open DOUBLE PRECISION,
    high DOUBLE PRECISION,
    low DOUBLE PRECISION,
    close DOUBLE PRECISION,
    volume_quote DOUBLE PRECISION,
    PRIMARY KEY (time, symbol)
);

SELECT create_hypertable('klines_1m', 'time', if_not_exists => TRUE);

CREATE TABLE IF NOT EXISTS trade_log (
    id BIGSERIAL PRIMARY KEY,
    symbol TEXT NOT NULL,
    entry_time TIMESTAMPTZ NOT NULL,
    exit_time TIMESTAMPTZ,
    entry_price DOUBLE PRECISION,
    exit_price DOUBLE PRECISION,
    reason TEXT,
    pnl_pct DOUBLE PRECISION,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_trade_symbol_time
ON trade_log (symbol, entry_time DESC);

CREATE TABLE IF NOT EXISTS positions_open (
  symbol TEXT PRIMARY KEY,
  entry_time TIMESTAMPTZ NOT NULL,
  entry_price DOUBLE PRECISION NOT NULL,
  sl DOUBLE PRECISION NOT NULL,
  tp DOUBLE PRECISION NOT NULL,
  status TEXT NOT NULL DEFAULT 'OPEN', -- OPEN | CLOSING
  opened_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_positions_open_status ON positions_open(status);


Pokud chceš, příště ti:

přidám detailní trade_log do DB

přidám BE move

přidám batch insert

přidám advanced risk control

1️⃣ Udělat SQL, který spočítá kompletní metriky (winrate, expectancy, PF)?
2️⃣ Přidat do systému automatické denní reporty?
3️⃣ Vysvětlit, jak poznáš, že strategie má skutečný edge?

1️⃣ Robustnosti (monitoring, healthcheck, alerty)
2️⃣ Výkonnosti strategie (optimalizace edge)
3️⃣ Risk managementu (position sizing, portfolio control)
4️⃣ Analytiky (dashboard + metriky)


-vypis konkretni env:
-------------------------------------------------docker exec -it pump_app printenv | sort
-------------------------------------------------docker exec -it pump_app printenv | grep -E "OBI_|PARTIAL|TRAIL|TP_R"

------------------------------------------------------------------------docker compose up -d --force-recreate entry
------------------------------------------------------------------------docker images poctak/pump-acumulation_entry --digests
------------------------------------------------------------------------docker compose up -d --force-recreate --no-build accumulation_entry

-----------------------------------------------------------docker logs --tail 50000 pump_entry 2>&1 | grep -F "A"
///////////////////////////////////////////////////////////docker logs --tail 500000 pump_entry 2>&1 | grep -F "⚡"
 ------------------------------------------------------------------------docker images --no-trunc | grep pump-acumulation_entry
////////////////////////////////////////////////////////// docker exec -it timescaledb psql -U pumpuser -d pumpdb -c "\dt public.*"

 public | accum_features_5m | table | pumpuser
 public | accum_signals     | table | pumpuser
 public | candles_5m        | table | pumpuser
 public | candles_5m_ac     | table | pumpuser
 public | klines_1m         | table | pumpuser
 public | positions_closed  | table | pumpuser
 public | positions_open    | table | pumpuser
 public | spot_fills        | table | pumpuser
 public | spot_orders       | table | pumpuser
 public | ticks             | table | pumpuser
 public | trade_intents     | table | pumpuser
 public | trade_log         | table | pumpuser




Rychlé doporučení k ladění

Pokud uvidíš, že ti to moc často “nechce ride” kvůli sell wall:

sniž WALL_RATIO třeba na 5.0 (detekuje víc wallů → spíš bude exitovat)

nebo zvýš na 8.0 (bude ignorovat menší wally → víc riding)

Pokud buy wall “moc drží” a nechává tě dlouho ve trade:

sniž BUY_WALL_EXTRA_TOLERANCE z 0.03 na 0.015

Co bych dělal u “pump” strategie (prakticky)
Varianta A (doporučená): 1m svíčky + “early warning” během svíčky

Alert: během svíčky (x=False) když cena překročí práh (např. +3 % vs baseline)

Confirm/entry: až na close (x=True) nebo po N sekundách nad prahem

Výhoda: rychlé varování, ale disciplinované potvrzení.

Varianta B: vlastní 30s svíčky z trades (pokročilé)

bereš aggTrade stream (agregované obchody)

skládáš OHLCV do 30s bucketů

děláš detekci

Výhoda: nejrychlejší a nejpřesnější microstructure.
Nevýhoda: víc práce, víc dat, víc rizik (lag, backpressure, správné bucketování).

Doporučení pro tebe (když jedeš 50 USDT párů a “abnormální nárůst vs 30min průměr”)

Zůstaň na 1m jako “hlavní timeframe” (signál stabilní, méně falešných vstupů).

Přidej early-warning během svíčky (bez vstupu), ať víš o pumpě dřív.

Pokud uvidíš, že ti unikají rychlé pumpy, teprve pak řeš 30s (z trades).

Konkrétní “rychlejší než 1m” bez 30s svíček

Uprav logiku tak, aby:

při x=False jen aktualizovala “current candle state”

když překročí práh, dá warning log

vstup jen při x=True (close) nebo po potvrzení

Jestli chceš, napíšu ti přesný návrh logiky:

práh na cenu vs MA(30m)

práh na objem (quote volume)

potvrzení (2 z 3 podmínek, nebo “držení nad prahem 10–20s”)

a jak to udělat, aby on_closed_candle() neblokoval websocket.

3. Sleduj "Spread" a likviditu
Úzký spread (malý rozdíl mezi nejlepší nabídkou a poptávkou): Znamená vysokou likviditu. Cena se pohybuje plynule.

Široký spread: Znamená nízkou likviditu. Riziko, že cena prudce spadne (slippage), je vysoké. Pokud se spread začne rozšiřovat, je čas na prodej.


Jasně — stručně ten tok po vyhlášení accumulation phase (tj. když to vyhodnotíš jako “OK, tohle je akumulace a chci z toho udělat kandidáta na obchod”) typicky vypadá takhle:

Detekce / vyhlášení accumulation phase (v kódu)

Vyhodnotíš podmínky (support touches, profit hits, okno času, atd.).

Když projde, vytvoříš “signal” objekt (symbol, timeframe, timestamp, feature hodnoty, důvod).

INSERT do acum_signals (auditní stopa signálu)

Do acum_signals uložíš jeden řádek = “v čase X jsem pro symbol Y detekoval accumulation phase” + metriky/důvody.

To je hlavně log/trace, aby šlo zpětně dohledat, proč to bot chtěl obchodovat.

SELECT do DB (gating: je to vůbec obchodovatelné?)
Než založíš “záměr obchodovat”, typicky uděláš kontroly přes SELECTy:

už nemám otevřenou pozici? → SELECT ... FROM positions_open WHERE symbol=... AND status='OPEN'

už jsem nedal intent / signal nedávno? (debounce / cooldown) → SELECT ... FROM trade_intents ... nebo poslední signal

případně další “duplicitní” ochrany (časové okno, max počet pozic, risk-on/off režim…)

INSERT do trade_intents (záměr koupit / čekání na exekuci)

Pokud gating prošel, vložíš do trade_intents řádek typu BUY intent:

symbol, čas, “source=ACUM”, parametry (navržený entry/sl/tp nebo jen důvod + plán), status třeba NEW/PENDING.

Tohle je už fronta práce pro exekuci (nebo pro další fázi, která čeká na potvrzení/podmínku).

Exekuce nákupu (jiná část systému / service)

Trade executor si vezme trade_intents ve stavu NEW/PENDING, provede market/limit buy (nebo paper trade), získá reálnou entry cenu.

INSERT do positions_open (vznikne otevřená pozice)

Po úspěšné exekuci vložíš do positions_open:

symbol, entry_time, entry_price, sl, tp, status='OPEN' (+ timestamps).

Tím se stává pozice “oficiálně otevřená” a od té chvíle ji sleduje exit logika.

(volitelně) update stavu intentu

trade_intents se obvykle přepne na EXECUTED/FILLED nebo FAILED, aby se nevzal znovu.
